#!/usr/bin/env bash
set -e

ENV_FILE=/etc/container_env

echo "# autogenerated env file for cron jobs" > ${ENV_FILE}

# --- Defaults for Postgres ---
: "${POSTGRES_USER:=postgres}" && export POSTGRES_USER
: "${POSTGRES_DB:=postgres}" && export POSTGRES_DB
: "${POSTGRES_PASSWORD:=postgres}" && export POSTGRES_PASSWORD

# --- Defaults for ETL ---
: "${API_URL:=https://jsonplaceholder.typicode.com/posts}" && export API_URL
: "${CRON_EXTRACT:=*/5 * * * *}" && export CRON_EXTRACT
: "${CRON_TRANSFORM:=*/10 * * * *}" && export CRON_TRANSFORM
: "${RETRIES:=3}" && export RETRIES
: "${LOG_LEVEL:=INFO}" && export LOG_LEVEL

# --- Save variables for cron ---
for k in $(printenv | awk -F= '{print $1}'); do
  case "$k" in
    API_*|CRON_*|RETRIES|LOG_LEVEL|DATABASE_URL|DB_*|POSTGRES_*)
      v=$(printenv "$k" | sed 's/"/\\"/g')
      echo "export $k=\"$v\"" >> ${ENV_FILE}
    ;;
  esac
done

# --- Start cron service ---
service cron start

# --- Ensure scripts are executable ---
chmod +x /usr/local/bin/scripts/*.sh || true
chmod +x /usr/local/bin/scripts/*.py || true

WEB_SCRIPT=/usr/local/bin/scripts/web.py
if [ -f "${WEB_SCRIPT}" ]; then
  # ensure it's executable
  chmod +x "${WEB_SCRIPT}" || true
  # start via nohup so it won't die when we exec postgres
  echo "[INFO] Старт web-дашборда на порту ${WEB_PORT:-8080} ..."
  nohup python3 "${WEB_SCRIPT}" > /var/log/json_web.log 2>&1 &
fi

echo "[INFO] Контейнер выполняется, cron работает, Postgres entrypoint выполняется..."

# --- Hand over to default Postgres entrypoint ---
exec docker-entrypoint.sh "$@"
